# TEST UNITAIRE

##### Le test unitaire permet de tester une partie spécifique de votre application (généralement une fonction). - Il permet d’éviter les effets de bord : pour un paramètre donné, le résultat sera toujours le même. - Les tests permettent à la fois de fiabiliser les applications et de décomplexifier la base de code. Une fonction difficilement testable est souvent une fonction qui doit être refactorisée pour pouvoir être mieux testée. - Essayez toujours de commencer par réaliser des tests sur les parties les plus complexes et les plus critiques de votre application. Ce sont ces dernières qui auront souvent le plus de chance de casser.- Attention au “Et si” lors de la phase de rédaction de votre test. Il est important que vous sachiez à quoi vous intéresser lors de la rédaction de votre test.

##### Décomposons ensemble ce bloc de code : Dans un premier temps, j’importe le code du fichier js/common/pagination/index.js . - describe vous permet de créer un bloc de tests (ou “Test Suite”, en anglais). Ce n’est pas un élément obligatoire, mais cela permet de renseigner le type de test que vous réalisez. - it contient le message indiquant le résultat attendu. On écrit souvent les tests sous la forme : it(‘should ...’). Par exemple, it(‘should return something’) ou en français, “ça devrait retourner quelque chose”. Il est important ici de faire un message le plus synthétique et complet possible. - expect() va vous permettre d'exécuter la fonction et de stocker la valeur de retour de cette dernière. - toBeDefined() ou toEqual() est le test en lui-même. C’est ce qu’on appelle le “matcher” côté test. Autrement dit, Jest va tester si le résultat de expect() correspond au “matcher”.
